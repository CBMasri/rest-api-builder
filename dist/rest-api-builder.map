{"version":3,"sources":["webpack://rest-api-builder/webpack/universalModuleDefinition","webpack://rest-api-builder/./src/builder.js","webpack://rest-api-builder/./src/constants.js","webpack://rest-api-builder/./src/errors.js","webpack://rest-api-builder/./src/utils.js","webpack://rest-api-builder/./src/validation.js","webpack://rest-api-builder/./node_modules/path-to-regexp/dist.es2015/index.js","webpack://rest-api-builder/webpack/bootstrap","webpack://rest-api-builder/webpack/runtime/define property getters","webpack://rest-api-builder/webpack/runtime/hasOwnProperty shorthand","webpack://rest-api-builder/webpack/runtime/make namespace object","webpack://rest-api-builder/webpack/startup"],"names":["pathToRegexp","compile","require","MissingIdError","MissingPayloadError","validateConfig","validateEndpoints","cleanURLSegment","APIBuilder","constructor","config","requestFn","baseURL","appendSlash","defaultActions","list","method","path","retrieve","create","update","partialUpdate","destroy","endpoints","Error","TypeError","length","_createDefaultActions","_createActions","actions","action","Object","entries","_requestFn","hasOwnProperty","toLowerCase","basePath","idRequired","_idRequired","payloadRequired","_payloadRequired","args","id","data","extra","_parseArgs","undefined","includes","requestConfig","url","_buildUrl","endpoint","requireId","hasNamedSegment","requirePayload","fullPath","toPath","encode","encodeURIComponent","idIsObj","keys","name","module","exports","HTTP_METHODS","DEFAULT_ACTIONS","ExtendableError","message","defineProperty","value","captureStackTrace","stack","__proto__","prototype","segment","startsWith","slice","endsWith","index","join"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,cAAc;AAC3C;AACA,oEAAoE,UAAU,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,cAAc;AAC3C,oEAAoE,UAAU,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAiD,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,cAAc;AAC3C,wOAAwO,UAAU,EAAE;AACpP;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAA6D;AAC3E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;UC7YA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"rest-api-builder.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"rest-api-builder\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rest-api-builder\"] = factory();\n\telse\n\t\troot[\"rest-api-builder\"] = factory();\n})(this, function() {\nreturn ","const { pathToRegexp, compile } = require('path-to-regexp')\n\nconst { MissingIdError, MissingPayloadError } = require('./errors.js')\nconst { validateConfig, validateEndpoints } = require('./validation.js')\nconst { cleanURLSegment } = require('./utils.js')\n\nclass APIBuilder {\n  /**\n   * Instantiate the builder.\n   *\n   * @param {Object} config - configuration object\n   * @param {Function} config.requestFn - Request handler\n   * @param {String} [config.baseURL] - Base URL path that will be prepended to all routes\n   */\n  constructor (config = {}) {\n    const {\n      requestFn = null,\n      baseURL = '',\n      appendSlash = true\n    } = config\n\n    validateConfig(config)\n\n    this.requestFn = requestFn\n    this.baseURL = cleanURLSegment(baseURL)\n    this.appendSlash = appendSlash\n\n    this.defaultActions = {\n      list: { method: 'get', path: '' },\n      retrieve: { method: 'get', path: ':id' },\n      create: { method: 'post', path: '' },\n      update: { method: 'put', path: ':id' },\n      partialUpdate: { method: 'patch', path: ':id' },\n      destroy: { method: 'delete', path: ':id' }\n    }\n  }\n\n  /**\n   * Build the rest api endpoints.\n   *\n   * @param {Object} config - endpoint configuration\n   * @param {String} config.path - route path\n   * @param {Object[]} config.endpoints - list of endpoint definitions\n   * @returns {Object}\n   */\n  create (config = {}) {\n    const {\n      path = '',\n      endpoints = []\n    } = config\n\n    if (!path) {\n      throw new Error('path is required')\n    }\n    if (typeof path !== 'string') {\n      throw new TypeError('path must be a string')\n    }\n\n    validateEndpoints(endpoints)\n\n    if (!endpoints.length) {\n      return this._createDefaultActions(path)\n    }\n    return this._createActions(endpoints, path)\n  }\n\n  /**\n   * When no actions are specified by the user,\n   * create the defaults.\n   *\n   * @param {String} path\n   * @returns {Object}\n   */\n  _createDefaultActions (path) {\n    const actions = {}\n\n    for (const [action, config] of Object.entries(this.defaultActions)) {\n      actions[action] = this._requestFn(path, config)\n    }\n    return actions\n  }\n\n  /**\n   * Generate an action using the user-provided\n   * configration object. These can be the default\n   * actions (eg. list, retrieve, update) or custom\n   * actions which define their own path.\n   *\n   * @param {Object[]} endpoints\n   * @param {String} path\n   * @returns {Object}\n   */\n  _createActions (endpoints, path) {\n    const actions = {}\n\n    for (let config of endpoints) {\n      const action = config.action\n\n      if (this.defaultActions.hasOwnProperty(action)) {\n        config = this.defaultActions[action]\n      } else {\n        config.method = config.method.toLowerCase()\n      }\n      actions[action] = this._requestFn(path, config)\n    }\n    return actions\n  }\n\n  /**\n   * Creates a method which calls the requestFn, and pass\n   * it the request config object.\n   *\n   * This method can be invoked using the `action` param.\n   *\n   * @param {String} basePath\n   * @param {Object} config - route configration\n   * @param {String} config.method - http verb\n   * @param {String} config.path - route path\n   * @param {String} [config.action] - action name, only set if custom\n   * @returns {Function}\n   */\n  _requestFn (basePath, config) {\n    const idRequired = this._idRequired(config)\n    const payloadRequired = this._payloadRequired(config)\n\n    return async (...args) => {\n      const { id, data, extra } = this._parseArgs(args, config)\n\n      if (idRequired) {\n        if (id === undefined) {\n          throw new MissingIdError()\n        }\n        if (!['string', 'number', 'object'].includes(typeof id)) {\n          throw new TypeError(\n            `Invalid type for id (${typeof id}). Allowed types: string, number, object`\n          )\n        }\n      }\n      if (payloadRequired && data === undefined) {\n        throw new MissingPayloadError()\n      }\n\n      const requestConfig = {\n        method: config.method,\n        url: this._buildUrl(basePath, config.path, id),\n        ...extra\n      }\n      if (data !== undefined) {\n        requestConfig.data = data\n      }\n\n      return this.requestFn(requestConfig)\n    }\n  }\n\n  /**\n   * Determine if the invocation method should accept\n   * an `id` parameter.\n   *\n   * The id wil be required for retrieve, update, partialUpdate\n   * destroy, or if a custom path is used which contains at\n   * least one named segment.\n   *\n   * @param {Object} endpoint - endpoint config\n   * @return {Boolean}\n   */\n  _idRequired (endpoint) {\n    const requireId = ['retrieve', 'update', 'partialUpdate', 'destroy']\n    const hasNamedSegment = endpoint.path.includes(':')\n    return requireId.includes(endpoint.action) || hasNamedSegment\n  }\n\n  /**\n   * Determines if the invocation method should\n   * accept a `data` parameter.\n   *\n   * A payload will be required for POST, PUT, PATCH.\n   *\n   * @param {Object} endpoint - endpoint config\n   * @returns {Boolean}\n   */\n  _payloadRequired (endpoint) {\n    const requirePayload = ['post', 'put', 'patch']\n    return requirePayload.includes(endpoint.method)\n  }\n\n  /**\n   * Parse the requestFn arguments into `id`,\n   * `data`, and `extra`. The order of args\n   * will differ based on the http method.\n   *\n   * @param {Array} args - requestFn arguments\n   * @param {Object} config - endpoint config\n   * @param {String} config.method - http method\n   * @param {String} config.path - route path\n   * @param {String} [config.action] - action name, only set if custom\n   * @returns {Object}\n   */\n  _parseArgs (args, config) {\n    let id, data, extra\n\n    // If `id` is required, `extra` will be either the\n    // 2nd or 3rd argument depending on the http method\n    if (this._idRequired(config)) {\n      id = args[0]\n      extra = args[1]\n      if (this._payloadRequired(config)) {\n        data = args[1]\n        extra = args[2]\n      }\n    } else {\n      switch (config.method) {\n        case 'get':\n        case 'delete':\n          extra = args[0]\n          break\n        case 'post':\n        case 'put':\n        case 'patch':\n          data = args[0]\n          extra = args[1]\n          break\n      }\n    }\n    extra = extra || {}\n    return { id, data, extra }\n  }\n\n  /**\n   * Construct the url which will be used to make\n   * requests to the server.\n   *\n   * @param {String} basePath - base path to resource\n   * @param {String} path - route path, will be appended to basePath\n   * @param {(String|Number|Object)} [id] - resource identifier(s)\n   * @returns {String}\n   */\n  _buildUrl (basePath, path, id) {\n    let fullPath = cleanURLSegment(basePath)\n\n    if (path) {\n      const toPath = compile(path, { encode: encodeURIComponent })\n      const idIsObj = typeof id === 'object'\n\n      // Collect named url params from path\n      const keys = []\n      pathToRegexp(path, keys)\n\n      // Fill in those values using the id\n      if (keys.length > 0) {\n        if (id === undefined) {\n          throw new Error('path specifies a named param but no id was given')\n        }\n        if (keys.length === 1) {\n          if (idIsObj) {\n            throw new TypeError('Received non-primitive value for id')\n          }\n          fullPath += `/${toPath({ [keys[0].name]: id })}`\n        } else {\n          if (!idIsObj) {\n            throw new Error('Expected object id for path with multiple named params')\n          }\n          fullPath += `/${toPath(id)}`\n        }\n      } else {\n        fullPath += `/${toPath()}`\n      }\n    }\n    const url = this.baseURL ? `${this.baseURL}/${fullPath}` : `/${fullPath}`\n    return this.appendSlash ? `${url}/` : url\n  }\n}\n\nmodule.exports = APIBuilder\n","// Constants\nconst HTTP_METHODS = ['head', 'get', 'post', 'put', 'patch', 'delete']\nconst DEFAULT_ACTIONS = ['list', 'retrieve', 'create', 'update', 'partialUpdate', 'destroy']\n\nmodule.exports = {\n  HTTP_METHODS,\n  DEFAULT_ACTIONS\n}\n","/* eslint-disable no-proto */\n\n/**\n * Extendable error class which allows for a custom error name/message.\n */\nclass ExtendableError extends Error {\n  constructor (message = '') {\n    super(message)\n\n    Object.defineProperty(this, 'message', { value: message })\n    Object.defineProperty(this, 'name', { value: this.constructor.name })\n\n    if (Error.hasOwnProperty('captureStackTrace')) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      Object.defineProperty(this, 'stack', (new Error(message)).stack)\n    }\n  }\n}\n\nclass MissingIdError extends ExtendableError {\n  constructor (message = 'Unable to complete request: missing resource identifier') {\n    super(message)\n\n    this.constructor = MissingIdError\n    this.__proto__ = MissingIdError.prototype\n  }\n}\n\nclass MissingPayloadError extends ExtendableError {\n  constructor (message = 'Unable to complete request: payload is required') {\n    super(message)\n\n    this.constructor = MissingPayloadError\n    this.__proto__ = MissingPayloadError.prototype\n  }\n}\n\nmodule.exports = {\n  MissingIdError,\n  MissingPayloadError\n}\n","/**\n * Trim leading and trailing slashes.\n *\n * @param {String} path\n */\nfunction cleanURLSegment (segment) {\n  if (segment.startsWith('/')) {\n    segment = segment.slice(1)\n  }\n  if (segment.endsWith('/')) {\n    segment = segment.slice(0, -1)\n  }\n  return segment\n}\n\nmodule.exports = {\n  cleanURLSegment\n}\n","const { DEFAULT_ACTIONS, HTTP_METHODS } = require('./constants.js')\n\n/**\n * Validate the APIBuilder configuration.\n *\n * @param {Object} config - Builder configuration options\n * @param {Function} config.requestFn - Request handler\n * @param {String} [config.baseURL] - Base URL path that will be prepended to all routes\n * @returns {Boolean}\n */\nfunction validateConfig (config) {\n  if (!config.hasOwnProperty('requestFn')) {\n    throw new Error('requestFn is required')\n  }\n  if (typeof config.requestFn !== 'function') {\n    throw new TypeError('requestFn must be a function')\n  }\n  if (config.hasOwnProperty('baseURL') && typeof config.baseURL !== 'string') {\n    throw new TypeError('baseURL must be a string')\n  }\n  if (config.hasOwnProperty('appendSlash') && typeof config.appendSlash !== 'boolean') {\n    throw new TypeError('appendSlash must be a boolean')\n  }\n}\n\n/**\n * Validate the endpoint schema contains well-formed data.\n *\n * @param {Object[]} endpoints\n * @returns {Boolean}\n */\nfunction validateEndpoints (endpoints) {\n  for (const [index, endpoint] of endpoints.entries()) {\n    // All endpoints need an action\n    if (!endpoint.action) {\n      throw new Error(`endpoint at pos ${index} is missing an action`)\n    }\n    // Custom endpoints must also define the http method and path\n    if (!DEFAULT_ACTIONS.includes(endpoint.action)) {\n      if (!endpoint.method) {\n        throw new Error(`endpoint at pos ${index} is missing a method`)\n      }\n      if (!HTTP_METHODS.includes(endpoint.method.toLowerCase())) {\n        throw new Error(`\n          endpoint at pos ${index} has an unknown method: ${endpoint.method}\\n\n          The allowed http methods are: ${HTTP_METHODS.join(', ')}\n        `)\n      }\n      if (!endpoint.hasOwnProperty('path')) {\n        throw new Error(`endpoint at pos ${index} is missing a path`)\n      }\n      if (typeof endpoint.path !== 'string') {\n        throw new TypeError(\n          `endpoint at pos ${index} has an invalid type for path: ${typeof endpoint.path}`\n        )\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  validateConfig,\n  validateEndpoints\n}\n","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\"\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./src/builder.js\");\n"],"sourceRoot":""}