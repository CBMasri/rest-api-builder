{"version":3,"sources":["webpack://rest-api-builder/webpack/universalModuleDefinition","webpack://rest-api-builder/./index.js","webpack://rest-api-builder/./src/builder.js","webpack://rest-api-builder/./src/constants.js","webpack://rest-api-builder/./src/errors.js","webpack://rest-api-builder/./src/utils.js","webpack://rest-api-builder/./src/validation.js","webpack://rest-api-builder/./node_modules/path-to-regexp/dist.es2015/index.js","webpack://rest-api-builder/webpack/bootstrap","webpack://rest-api-builder/webpack/startup","webpack://rest-api-builder/webpack/runtime/define property getters","webpack://rest-api-builder/webpack/runtime/hasOwnProperty shorthand","webpack://rest-api-builder/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","this","pathToRegexp","compile","require","MissingIdError","MissingPayloadError","validateConfig","validateEndpoints","cleanURLSegment","constructor","config","baseURL","requestFn","defaultActions","list","method","path","retrieve","create","update","partialUpdate","destroy","endpoints","Error","TypeError","length","_createActions","_createDefaultActions","actions","action","Object","entries","_requestFn","hasOwnProperty","toLowerCase","basePath","idRequired","_idRequired","payloadRequired","_payloadRequired","async","args","id","data","extra","_parseArgs","undefined","includes","requestConfig","url","_buildUrl","endpoint","hasNamedSegment","toPath","encode","encodeURIComponent","idIsObj","keys","name","HTTP_METHODS","DEFAULT_ACTIONS","ExtendableError","message","super","defineProperty","value","captureStackTrace","stack","__proto__","prototype","segment","startsWith","slice","endsWith","index","join","parse","str","options","tokens","i","char","push","type","count","pattern","j","code","charCodeAt","lexer","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","tryConsume","mustConsume","nextType","consumeText","prefix","indexOf","suffix","modifier","name_1","pattern_1","tokensToFunction","reFlags","flags","x","_b","validate","matches","map","token","RegExp","optional","repeat","Array","isArray","test","typeOfMessage","String","match","regexpToFunction","re","decode","pathname","m","exec","params","_loop_1","split","replace","sensitive","tokensToRegexp","strict","start","_c","end","_d","route","_i","tokens_1","mod","endToken","isEndDelimited","groupsRegex","execResult","source","regexpToRegexp","paths","parts","arrayToRegexp","stringToRegexp","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","o","enumerable","get","obj","prop","call","r","Symbol","toStringTag"],"mappings":"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","file":"rest-api-builder.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"rest-api-builder\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rest-api-builder\"] = factory();\n\telse\n\t\troot[\"rest-api-builder\"] = factory();\n})(this, function() {\nreturn ","module.exports = require('./src/builder.js')\n","const { pathToRegexp, compile } = require('path-to-regexp')\n\nconst { MissingIdError, MissingPayloadError } = require('./errors.js')\nconst { validateConfig, validateEndpoints } = require('./validation.js')\nconst { cleanURLSegment } = require('./utils.js')\n\nclass APIBuilder {\n  /**\n   * Instantiate the builder.\n   *\n   * @param {Object} config - configuration object\n   * @param {Function} config.requestFn - Request handler\n   * @param {String} [config.baseURL] - Base URL path that will be prepended to all routes\n   */\n  constructor (config = {}) {\n    const {\n      baseURL = '',\n      requestFn = null\n    } = config\n\n    validateConfig(config)\n\n    this.baseURL = cleanURLSegment(baseURL)\n    this.requestFn = requestFn\n    this.defaultActions = {\n      list: { method: 'get', path: '' },\n      retrieve: { method: 'get', path: ':id' },\n      create: { method: 'post', path: '' },\n      update: { method: 'put', path: ':id' },\n      partialUpdate: { method: 'patch', path: ':id' },\n      destroy: { method: 'delete', path: ':id' }\n    }\n  }\n\n  /**\n   * Build the rest api endpoints.\n   *\n   * @param {Object} config - endpoint configuration\n   * @param {String} config.path - route path\n   * @param {Object[]} config.endpoints - list of endpoint definitions\n   * @returns {Object}\n   */\n  create (config = {}) {\n    const {\n      path = '',\n      endpoints = []\n    } = config\n\n    if (!path) {\n      throw new Error('path is required')\n    }\n    if (typeof path !== 'string') {\n      throw new TypeError('path must be a string')\n    }\n\n    validateEndpoints(endpoints)\n\n    if (!endpoints.length) {\n      return this._createDefaultActions(path)\n    }\n    return this._createActions(endpoints, path)\n  }\n\n  /**\n   * When no actions are specified by the user,\n   * create the defaults.\n   *\n   * @param {String} path\n   * @returns {Object}\n   */\n  _createDefaultActions (path) {\n    const actions = {}\n\n    for (const [action, config] of Object.entries(this.defaultActions)) {\n      actions[action] = this._requestFn(path, config)\n    }\n    return actions\n  }\n\n  /**\n   * Generate an action using the user-provided\n   * configration object. These can be the default\n   * actions (eg. list, retrieve, update) or custom\n   * actions which define their own path.\n   *\n   * @param {Object[]} endpoints\n   * @param {String} path\n   * @returns {Object}\n   */\n  _createActions (endpoints, path) {\n    const actions = {}\n\n    for (let config of endpoints) {\n      const action = config.action\n\n      if (this.defaultActions.hasOwnProperty(action)) {\n        config = this.defaultActions[action]\n      } else {\n        config.method = config.method.toLowerCase()\n      }\n      actions[action] = this._requestFn(path, config)\n    }\n    return actions\n  }\n\n  /**\n   * Creates a method which calls the requestFn, and pass\n   * it the request config object.\n   *\n   * This method can be invoked using the `action` param.\n   *\n   * @param {String} basePath\n   * @param {Object} config - route configration\n   * @param {String} config.method - http verb\n   * @param {String} config.path - route path\n   * @param {String} [config.action] - action name, only set if custom\n   * @returns {Function}\n   */\n  _requestFn (basePath, config) {\n    const idRequired = this._idRequired(config)\n    const payloadRequired = this._payloadRequired(config)\n\n    return async (...args) => {\n      const { id, data, extra } = this._parseArgs(args, config)\n\n      if (idRequired) {\n        if (id === undefined) {\n          throw new MissingIdError()\n        }\n        if (!['string', 'number', 'object'].includes(typeof id)) {\n          throw new TypeError(\n            `Invalid type for id (${typeof id}). Allowed types: string, number, object`\n          )\n        }\n      }\n      if (payloadRequired && data === undefined) {\n        throw new MissingPayloadError()\n      }\n\n      const requestConfig = {\n        method: config.method,\n        url: this._buildUrl(basePath, config.path, id),\n        ...extra\n      }\n      if (data !== undefined) {\n        requestConfig.data = data\n      }\n\n      return this.requestFn(requestConfig)\n    }\n  }\n\n  /**\n   * Determine if the invocation method should accept\n   * an `id` parameter.\n   *\n   * The id wil be required for retrieve, update, partialUpdate\n   * destroy, or if a custom path is used which contains at\n   * least one named segment.\n   *\n   * @param {Object} endpoint - endpoint config\n   * @return {Boolean}\n   */\n  _idRequired (endpoint) {\n    const requireId = ['retrieve', 'update', 'partialUpdate', 'destroy']\n    const hasNamedSegment = endpoint.path.includes(':')\n    return requireId.includes(endpoint.action) || hasNamedSegment\n  }\n\n  /**\n   * Determines if the invocation method should\n   * accept a `data` parameter.\n   *\n   * A payload will be required for POST, PUT, PATCH.\n   *\n   * @param {Object} endpoint - endpoint config\n   * @returns {Boolean}\n   */\n  _payloadRequired (endpoint) {\n    const requirePayload = ['post', 'put', 'patch']\n    return requirePayload.includes(endpoint.method)\n  }\n\n  /**\n   * Parse the requestFn arguments into `id`,\n   * `data`, and `extra`. The order of args\n   * will differ based on the http method.\n   *\n   * @param {Array} args - requestFn arguments\n   * @param {Object} config - endpoint config\n   * @param {String} config.method - http method\n   * @param {String} config.path - route path\n   * @param {String} [config.action] - action name, only set if custom\n   * @returns {Object}\n   */\n  _parseArgs (args, config) {\n    let id, data, extra\n\n    // If `id` is required, `extra` will be either the\n    // 2nd or 3rd argument depending on the http method\n    if (this._idRequired(config)) {\n      id = args[0]\n      extra = args[1]\n      if (this._payloadRequired(config)) {\n        data = args[1]\n        extra = args[2]\n      }\n    } else {\n      switch (config.method) {\n        case 'get':\n        case 'delete':\n          extra = args[0]\n          break\n        case 'post':\n        case 'put':\n        case 'patch':\n          data = args[0]\n          extra = args[1]\n          break\n      }\n    }\n    extra = extra || {}\n    return { id, data, extra }\n  }\n\n  /**\n   * Construct the url which will be used to make\n   * requests to the server.\n   *\n   * @param {String} basePath - base path to resource\n   * @param {String} path - route path, will be appended to basePath\n   * @param {(String|Number|Object)} [id] - resource identifier(s)\n   * @returns {String}\n   */\n  _buildUrl (basePath, path, id) {\n    let url = cleanURLSegment(basePath)\n\n    if (path) {\n      const toPath = compile(path, { encode: encodeURIComponent })\n      const idIsObj = typeof id === 'object'\n\n      // Collect named url params from path\n      const keys = []\n      pathToRegexp(path, keys)\n\n      // Fill in those values using the id\n      if (keys.length > 0) {\n        if (id === undefined) {\n          throw new Error('path specifies a named param but no id was given')\n        }\n        if (keys.length === 1) {\n          if (idIsObj) {\n            throw new TypeError('Received non-primitive value for id')\n          }\n          url += `/${toPath({ [keys[0].name]: id })}/`\n        } else {\n          if (!idIsObj) {\n            throw new Error('Expected object id for path with multiple named params')\n          }\n          url += `/${toPath(id)}/`\n        }\n      } else {\n        url += `/${toPath()}/`\n      }\n    }\n    return this.baseURL ? `${this.baseURL}/${url}` : `/${url}`\n  }\n}\n\nmodule.exports = APIBuilder\n","// Constants\nconst HTTP_METHODS = ['head', 'get', 'post', 'put', 'patch', 'delete']\nconst DEFAULT_ACTIONS = ['list', 'retrieve', 'create', 'update', 'partialUpdate', 'destroy']\n\nmodule.exports = {\n  HTTP_METHODS,\n  DEFAULT_ACTIONS\n}\n","/* eslint-disable no-proto */\n\n/**\n * Extendable error class which allows for a custom error name/message.\n */\nclass ExtendableError extends Error {\n  constructor (message = '') {\n    super(message)\n\n    Object.defineProperty(this, 'message', { value: message })\n    Object.defineProperty(this, 'name', { value: this.constructor.name })\n\n    if (Error.hasOwnProperty('captureStackTrace')) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      Object.defineProperty(this, 'stack', (new Error(message)).stack)\n    }\n  }\n}\n\nclass MissingIdError extends ExtendableError {\n  constructor (message = 'Unable to complete request: missing resource identifier') {\n    super(message)\n\n    this.constructor = MissingIdError\n    this.__proto__ = MissingIdError.prototype\n  }\n}\n\nclass MissingPayloadError extends ExtendableError {\n  constructor (message = 'Unable to complete request: payload is required') {\n    super(message)\n\n    this.constructor = MissingPayloadError\n    this.__proto__ = MissingPayloadError.prototype\n  }\n}\n\nmodule.exports = {\n  MissingIdError,\n  MissingPayloadError\n}\n","/**\n * Trim leading and trailing slashes.\n *\n * @param {String} path\n */\nfunction cleanURLSegment (segment) {\n  if (segment.startsWith('/')) {\n    segment = segment.slice(1)\n  }\n  if (segment.endsWith('/')) {\n    segment = segment.slice(0, -1)\n  }\n  return segment\n}\n\nmodule.exports = {\n  cleanURLSegment\n}\n","const { DEFAULT_ACTIONS, HTTP_METHODS } = require('./constants.js')\n\n/**\n * Validate the APIBuilder configuration.\n *\n * @param {Object} config - Builder configuration options\n * @param {Function} config.requestFn - Request handler\n * @param {String} [config.baseURL] - Base URL path that will be prepended to all routes\n * @returns {Boolean}\n */\nfunction validateConfig (config) {\n  if (!config.hasOwnProperty('requestFn')) {\n    throw new Error('requestFn is required')\n  }\n  if (typeof config.requestFn !== 'function') {\n    throw new TypeError('requestFn must be a function')\n  }\n  if (config.hasOwnProperty('baseURL') && typeof config.baseURL !== 'string') {\n    throw new TypeError('baseURL must be a string')\n  }\n}\n\n/**\n * Validate the endpoint schema contains well-formed data.\n *\n * @param {Object[]} endpoints\n * @returns {Boolean}\n */\nfunction validateEndpoints (endpoints) {\n  for (const [index, endpoint] of endpoints.entries()) {\n    // All endpoints need an action\n    if (!endpoint.action) {\n      throw new Error(`endpoint at pos ${index} is missing an action`)\n    }\n    // Custom endpoints must also define the http method and path\n    if (!DEFAULT_ACTIONS.includes(endpoint.action)) {\n      if (!endpoint.method) {\n        throw new Error(`endpoint at pos ${index} is missing a method`)\n      }\n      if (!HTTP_METHODS.includes(endpoint.method.toLowerCase())) {\n        throw new Error(`\n          endpoint at pos ${index} has an unknown method: ${endpoint.method}\\n\n          The allowed http methods are: ${HTTP_METHODS.join(', ')}\n        `)\n      }\n      if (!endpoint.hasOwnProperty('path')) {\n        throw new Error(`endpoint at pos ${index} is missing a path`)\n      }\n      if (typeof endpoint.path !== 'string') {\n        throw new TypeError(\n          `endpoint at pos ${index} has an invalid type for path: ${typeof endpoint.path}`\n        )\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  validateConfig,\n  validateEndpoints\n}\n","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\"\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(45);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}