{"version":3,"sources":["webpack://rest-api-builder/webpack/universalModuleDefinition","webpack://rest-api-builder/./node_modules/path-to-regexp/dist.es2015/index.js","webpack://rest-api-builder/./src/errors.js","webpack://rest-api-builder/./src/constants.js","webpack://rest-api-builder/./src/utils.js","webpack://rest-api-builder/./src/builder.js","webpack://rest-api-builder/./src/validation.js","webpack://rest-api-builder/webpack/bootstrap","webpack://rest-api-builder/webpack/startup","webpack://rest-api-builder/webpack/runtime/define property getters","webpack://rest-api-builder/webpack/runtime/hasOwnProperty shorthand","webpack://rest-api-builder/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","this","parse","str","options","tokens","i","length","char","push","type","index","value","count","pattern","j","TypeError","name","code","charCodeAt","lexer","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","path","tryConsume","mustConsume","undefined","nextType","consumeText","prefix","indexOf","suffix","modifier","name_1","pattern_1","replace","flags","sensitive","pathToRegexp","keys","RegExp","groupsRegex","execResult","exec","source","regexpToRegexp","Array","isArray","paths","parts","map","join","arrayToRegexp","strict","_b","start","_c","end","_d","encode","x","endsWith","route","_i","tokens_1","token","mod","endToken","isEndDelimited","tokensToRegexp","stringToRegexp","ExtendableError","Error","constructor","message","super","Object","defineProperty","hasOwnProperty","captureStackTrace","stack","MissingIdError","__proto__","prototype","MissingPayloadError","HTTP_METHODS","DEFAULT_ACTIONS","cleanURLSegment","segment","startsWith","slice","APIBuilder","config","baseURL","requestFn","validateConfig","defaultActions","list","method","retrieve","create","update","partialUpdate","destroy","endpoints","endpoint","entries","action","includes","toLowerCase","validateEndpoints","_createActions","_createDefaultActions","actions","_requestFn","basePath","idRequired","_idRequired","payloadRequired","_payloadRequired","async","args","id","data","extra","_parseArgs","requestConfig","url","_buildUrl","hasNamedSegment","toPath","encodeURIComponent","reFlags","validate","matches","optional","repeat","test","typeOfMessage","String","tokensToFunction","idIsObj","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","o","enumerable","get","obj","prop","call","r","Symbol","toStringTag"],"mappings":"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","file":"rest-api-builder.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"rest-api-builder\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rest-api-builder\"] = factory();\n\telse\n\t\troot[\"rest-api-builder\"] = factory();\n})(this, function() {\nreturn ","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\"\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable no-proto */\n\n/**\n * Extendable error class which allows for a custom error name/message.\n */\nexport class ExtendableError extends Error {\n  constructor (message = '') {\n    super(message)\n\n    Object.defineProperty(this, 'message', { value: message })\n    Object.defineProperty(this, 'name', { value: this.constructor.name })\n\n    if (Error.hasOwnProperty('captureStackTrace')) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      Object.defineProperty(this, 'stack', (new Error(message)).stack)\n    }\n  }\n}\n\nexport class MissingIdError extends ExtendableError {\n  constructor (message = 'Unable to complete request: missing resource identifier') {\n    super(message)\n\n    this.constructor = MissingIdError\n    this.__proto__ = MissingIdError.prototype\n  }\n}\n\nexport class MissingPayloadError extends ExtendableError {\n  constructor (message = 'Unable to complete request: payload is required') {\n    super(message)\n\n    this.constructor = MissingPayloadError\n    this.__proto__ = MissingPayloadError.prototype\n  }\n}\n","// Constants\nconst HTTP_METHODS = ['head', 'get', 'post', 'put', 'patch', 'delete']\nconst DEFAULT_ACTIONS = ['list', 'retrieve', 'create', 'update', 'partialUpdate', 'destroy']\n\nexport {\n  HTTP_METHODS,\n  DEFAULT_ACTIONS\n}\n","/**\n * Trim leading and trailing slashes.\n *\n * @param {String} path\n */\nexport function cleanURLSegment (segment) {\n  if (segment.startsWith('/')) {\n    segment = segment.slice(1)\n  }\n  if (segment.endsWith('/')) {\n    segment = segment.slice(0, -1)\n  }\n  return segment\n}\n","import { pathToRegexp, compile } from 'path-to-regexp'\n\nimport { MissingIdError, MissingPayloadError } from './errors.js'\nimport { validateConfig, validateEndpoints } from './validation.js'\nimport { cleanURLSegment } from './utils.js'\n\nexport default class APIBuilder {\n  /**\n   * Instantiate the builder.\n   *\n   * @param {Object} config - configuration object\n   * @param {Function} config.requestFn - Request handler\n   * @param {String} [config.baseURL] - Base URL path that will be prepended to all routes\n   */\n  constructor (config = {}) {\n    const {\n      baseURL = '',\n      requestFn = null\n    } = config\n\n    validateConfig(config)\n\n    this.baseURL = cleanURLSegment(baseURL)\n    this.requestFn = requestFn\n    this.defaultActions = {\n      list: { method: 'get', path: '' },\n      retrieve: { method: 'get', path: ':id' },\n      create: { method: 'post', path: '' },\n      update: { method: 'put', path: ':id' },\n      partialUpdate: { method: 'patch', path: ':id' },\n      destroy: { method: 'delete', path: ':id' }\n    }\n  }\n\n  /**\n   * Build the rest api endpoints.\n   *\n   * @param {Object} config - endpoint configuration\n   * @param {String} config.path - route path\n   * @param {Object[]} config.endpoints - list of endpoint definitions\n   * @returns {Object}\n   */\n  create (config = {}) {\n    const {\n      path = '',\n      endpoints = []\n    } = config\n\n    if (!path) {\n      throw new Error('path is required')\n    }\n    if (typeof path !== 'string') {\n      throw new TypeError('path must be a string')\n    }\n\n    validateEndpoints(endpoints)\n\n    if (!endpoints.length) {\n      return this._createDefaultActions(path)\n    }\n    return this._createActions(endpoints, path)\n  }\n\n  /**\n   * When no actions are specified by the user,\n   * create the defaults.\n   *\n   * @param {String} path\n   * @returns {Object}\n   */\n  _createDefaultActions (path) {\n    const actions = {}\n\n    for (const [action, config] of Object.entries(this.defaultActions)) {\n      actions[action] = this._requestFn(path, config)\n    }\n    return actions\n  }\n\n  /**\n   * Generate an action using the user-provided\n   * configration object. These can be the default\n   * actions (eg. list, retrieve, update) or custom\n   * actions which define their own path.\n   *\n   * @param {Object[]} endpoints\n   * @param {String} path\n   * @returns {Object}\n   */\n  _createActions (endpoints, path) {\n    const actions = {}\n\n    for (let config of endpoints) {\n      const action = config.action\n\n      if (this.defaultActions.hasOwnProperty(action)) {\n        config = this.defaultActions[action]\n      } else {\n        config.method = config.method.toLowerCase()\n      }\n      actions[action] = this._requestFn(path, config)\n    }\n    return actions\n  }\n\n  /**\n   * Creates a method which calls the requestFn, and pass\n   * it the request config object.\n   *\n   * This method can be invoked using the `action` param.\n   *\n   * @param {String} basePath\n   * @param {Object} config - route configration\n   * @param {String} config.method - http verb\n   * @param {String} config.path - route path\n   * @param {String} [config.action] - action name, only set if custom\n   * @returns {Function}\n   */\n  _requestFn (basePath, config) {\n    const idRequired = this._idRequired(config)\n    const payloadRequired = this._payloadRequired(config)\n\n    return async (...args) => {\n      const { id, data, extra } = this._parseArgs(args, config)\n\n      if (idRequired) {\n        if (id === undefined) {\n          throw new MissingIdError()\n        }\n        if (!['string', 'number', 'object'].includes(typeof id)) {\n          throw new TypeError(\n            `Invalid type for id (${typeof id}). Allowed types: string, number, object`\n          )\n        }\n      }\n      if (payloadRequired && data === undefined) {\n        throw new MissingPayloadError()\n      }\n\n      const requestConfig = {\n        method: config.method,\n        url: this._buildUrl(basePath, config.path, id),\n        ...extra\n      }\n      if (data !== undefined) {\n        requestConfig.data = data\n      }\n\n      return this.requestFn(requestConfig)\n    }\n  }\n\n  /**\n   * Determine if the invocation method should accept\n   * an `id` parameter.\n   *\n   * The id wil be required for retrieve, update, partialUpdate\n   * destroy, or if a custom path is used which contains at\n   * least one named segment.\n   *\n   * @param {Object} endpoint - endpoint config\n   * @return {Boolean}\n   */\n  _idRequired (endpoint) {\n    const requireId = ['retrieve', 'update', 'partialUpdate', 'destroy']\n    const hasNamedSegment = endpoint.path.includes(':')\n    return requireId.includes(endpoint.action) || hasNamedSegment\n  }\n\n  /**\n   * Determines if the invocation method should\n   * accept a `data` parameter.\n   *\n   * A payload will be required for POST, PUT, PATCH.\n   *\n   * @param {Object} endpoint - endpoint config\n   * @returns {Boolean}\n   */\n  _payloadRequired (endpoint) {\n    const requirePayload = ['post', 'put', 'patch']\n    return requirePayload.includes(endpoint.method)\n  }\n\n  /**\n   * Parse the requestFn arguments into `id`,\n   * `data`, and `extra`. The order of args\n   * will differ based on the http method.\n   *\n   * @param {Array} args - requestFn arguments\n   * @param {Object} config - endpoint config\n   * @param {String} config.method - http method\n   * @param {String} config.path - route path\n   * @param {String} [config.action] - action name, only set if custom\n   * @returns {Object}\n   */\n  _parseArgs (args, config) {\n    let id, data, extra\n\n    // If `id` is required, `extra` will be either the\n    // 2nd or 3rd argument depending on the http method\n    if (this._idRequired(config)) {\n      id = args[0]\n      extra = args[1]\n      if (this._payloadRequired(config)) {\n        data = args[1]\n        extra = args[2]\n      }\n    } else {\n      switch (config.method) {\n        case 'get':\n        case 'delete':\n          extra = args[0]\n          break\n        case 'post':\n        case 'put':\n        case 'patch':\n          data = args[0]\n          extra = args[1]\n          break\n      }\n    }\n    extra = extra || {}\n    return { id, data, extra }\n  }\n\n  /**\n   * Construct the url which will be used to make\n   * requests to the server.\n   *\n   * @param {String} basePath - base path to resource\n   * @param {String} path - route path, will be appended to basePath\n   * @param {(String|Number|Object)} [id] - resource identifier(s)\n   * @returns {String}\n   */\n  _buildUrl (basePath, path, id) {\n    let url = cleanURLSegment(basePath)\n\n    if (path) {\n      const toPath = compile(path, { encode: encodeURIComponent })\n      const idIsObj = typeof id === 'object'\n\n      // Collect named url params from path\n      const keys = []\n      pathToRegexp(path, keys)\n\n      // Fill in those values using the id\n      if (keys.length > 0) {\n        if (id === undefined) {\n          throw new Error('path specifies a named param but no id was given')\n        }\n        if (keys.length === 1) {\n          if (idIsObj) {\n            throw new TypeError('Received non-primitive value for id')\n          }\n          url += `/${toPath({ [keys[0].name]: id })}/`\n        } else {\n          if (!idIsObj) {\n            throw new Error('Expected object id for path with multiple named params')\n          }\n          url += `/${toPath(id)}/`\n        }\n      } else {\n        url += `/${toPath()}/`\n      }\n    }\n    return this.baseURL ? `${this.baseURL}/${url}` : `/${url}`\n  }\n}\n","import { DEFAULT_ACTIONS, HTTP_METHODS } from './constants.js'\n\n/**\n * Validate the APIBuilder configuration.\n *\n * @param {Object} config - Builder configuration options\n * @param {Function} config.requestFn - Request handler\n * @param {String} [config.baseURL] - Base URL path that will be prepended to all routes\n * @returns {Boolean}\n */\nexport function validateConfig (config) {\n  if (!config.hasOwnProperty('requestFn')) {\n    throw new Error('requestFn is required')\n  }\n  if (typeof config.requestFn !== 'function') {\n    throw new TypeError('requestFn must be a function')\n  }\n  if (config.hasOwnProperty('baseURL') && typeof config.baseURL !== 'string') {\n    throw new TypeError('baseURL must be a string')\n  }\n}\n\n/**\n * Validate the endpoint schema contains well-formed data.\n *\n * @param {Object[]} endpoints\n * @returns {Boolean}\n */\nexport function validateEndpoints (endpoints) {\n  for (const [index, endpoint] of endpoints.entries()) {\n    // All endpoints need an action\n    if (!endpoint.action) {\n      throw new Error(`endpoint at pos ${index} is missing an action`)\n    }\n    // Custom endpoints must also define the http method and path\n    if (!DEFAULT_ACTIONS.includes(endpoint.action)) {\n      if (!endpoint.method) {\n        throw new Error(`endpoint at pos ${index} is missing a method`)\n      }\n      if (!HTTP_METHODS.includes(endpoint.method.toLowerCase())) {\n        throw new Error(`\n          endpoint at pos ${index} has an unknown method: ${endpoint.method}\\n\n          The allowed http methods are: ${HTTP_METHODS.join(', ')}\n        `)\n      }\n      if (!endpoint.hasOwnProperty('path')) {\n        throw new Error(`endpoint at pos ${index} is missing a path`)\n      }\n      if (typeof endpoint.path !== 'string') {\n        throw new TypeError(\n          `endpoint at pos ${index} has an invalid type for path: ${typeof endpoint.path}`\n        )\n      }\n    }\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(545);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}